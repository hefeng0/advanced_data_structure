!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABOVE_FACTOR	bptree/bptree.c	/^	ABOVE_FACTOR,$/;"	e	enum:__anon1	file:
BELOW_FACTOR	bptree/bptree.c	/^	BELOW_FACTOR,$/;"	e	enum:__anon1	file:
BIGGER_THAN	include/bptree.h	/^	BIGGER_THAN,$/;"	e	enum:COMPARE_VALUE
BPTREE_H	include/bptree.h	7;"	d
COLOR	rbtree/rbtree.c	16;"	d	file:
COLOR_BLACK	include/rbtree.h	/^	COLOR_BLACK,$/;"	e	enum:RBNODE_COLOR
COLOR_RED	include/rbtree.h	/^	COLOR_RED,$/;"	e	enum:RBNODE_COLOR
COMPARE_VALUE	include/bptree.h	/^enum COMPARE_VALUE {$/;"	g
EQUAL_TO	include/bptree.h	/^	EQUAL_TO,$/;"	e	enum:COMPARE_VALUE
INIT_LIST_HEAD	include/dlist.h	21;"	d
LESS_THAN	include/bptree.h	/^	LESS_THAN,$/;"	e	enum:COMPARE_VALUE
MATCH_FACTOR	bptree/bptree.c	/^	MATCH_FACTOR,$/;"	e	enum:__anon1	file:
MAX_LEVEL	include/skiplist.h	5;"	d
NIL	rbtree/rbtree.c	/^rbnode NIL={0, COLOR_BLACK, NULL, NULL, NULL};$/;"	v
NODE_TYPE	include/bptree.h	/^enum NODE_TYPE {$/;"	g
NODE_TYPE_LEAF	include/bptree.h	/^	NODE_TYPE_LEAF$/;"	e	enum:NODE_TYPE
NODE_TYPE_NORMAL	include/bptree.h	/^	NODE_TYPE_NORMAL,$/;"	e	enum:NODE_TYPE
RBNODE_COLOR	include/rbtree.h	/^enum RBNODE_COLOR {$/;"	g
__list_add	dlist/dlist.c	/^void __list_add(struct list_head *entry, struct list_head *prev, struct list_head *next)$/;"	f
__list_del	dlist/dlist.c	/^void __list_del(struct list_head *prev, struct list_head *next)$/;"	f
bptree	include/bptree.h	/^} bptree;$/;"	t	typeref:struct:bptree_
bptree_	include/bptree.h	/^typedef struct bptree_ {$/;"	s
bptree_create_node	bptree/bptree.c	/^bptree_node *bptree_create_node(bptree *tree, bptree_node *parent) $/;"	f
bptree_delete	bptree/bptree.c	/^bool bptree_delete(bptree *tree, void *key)$/;"	f
bptree_destroy	bptree/bptree.c	/^void bptree_destroy(bptree *tree)$/;"	f
bptree_dump	bptree/bptree.c	/^void bptree_dump(bptree *tree)$/;"	f
bptree_init	bptree/bptree.c	/^void bptree_init(bptree *tree, int m, int (*compare)(const void *, const void *), void (*destroy)(void *))$/;"	f
bptree_insert	bptree/bptree.c	/^bool bptree_insert(bptree *tree, void *key, void *data)$/;"	f
bptree_modify	bptree/bptree.c	/^bool bptree_modify(bptree *tree, void *key, void *data)$/;"	f
bptree_node	include/bptree.h	/^} bptree_node;$/;"	t	typeref:struct:bptree_node_
bptree_node_	include/bptree.h	/^typedef struct bptree_node_ {$/;"	s
bptree_node_key	include/bptree.h	/^} bptree_node_key;$/;"	t	typeref:struct:bptree_node_key_
bptree_node_key_	include/bptree.h	/^typedef struct bptree_node_key_ {$/;"	s
bptree_search	bptree/bptree.c	/^void *bptree_search(bptree *tree, bptree_node *node, void *key)$/;"	f
bptree_search_range	bptree/bptree.c	/^void *bptree_search_range(bptree *tree, void *key_low, void *key_high)$/;"	f
build_tree	bptree/main.c	/^void build_tree(bptree *tree, int m, int (*compare)(const void *, const void *), void (*destroy)(void *data))$/;"	f
check_black_depth	rbtree/rbtree.c	/^int check_black_depth(rbnode *node)$/;"	f
check_child	rbtree/rbtree.c	/^bool check_child(rbnode *node)$/;"	f
check_color	rbtree/rbtree.c	/^bool check_color(rbnode *node)$/;"	f
check_leaf_color	rbtree/rbtree.c	/^bool check_leaf_color(rbnode *node)$/;"	f
check_root	rbtree/rbtree.c	/^bool check_root(rbtree *tree)$/;"	f
child	include/bptree.h	/^		struct bptree_node_ *child;$/;"	m	union:bptree_node_key_::__anon2	typeref:struct:bptree_node_key_::__anon2::bptree_node_
color	include/rbtree.h	/^	int color;$/;"	m	struct:rbnode
compare	bptree/main.c	/^int compare(const void *left, const void *right)$/;"	f
compare	include/bptree.h	/^	int (*compare)(const void *left, const void *right);$/;"	m	struct:bptree_
container_for_each	include/dlist.h	29;"	d
container_of	include/dlist.h	23;"	d
count	include/rbtree.h	/^	int count;$/;"	m	struct:rbtree
count	include/skiplist.h	/^	int count;$/;"	m	struct:skiplist
data	dlist/main.c	/^	int data;$/;"	m	struct:test_node	file:
data	include/bptree.h	/^		void *data;$/;"	m	union:bptree_node_key_::__anon2
delete_key	bptree/bptree.c	/^void delete_key(bptree *tree, bptree_node *node, int idx_key)$/;"	f
delete_node	bptree/bptree.c	/^void delete_node(bptree *tree, bptree_node *node, void *parent_key)$/;"	f
destroy	bptree/main.c	/^void destroy(void *data)$/;"	f
destroy	include/bptree.h	/^	void (*destroy)(void *data);$/;"	m	struct:bptree_
destroy_node	bptree/bptree.c	/^void destroy_node(bptree *tree, bptree_node *node)$/;"	f
fixup_del	rbtree/rbtree.c	/^void fixup_del(rbtree *tree, rbnode *node)$/;"	f
fixup_insert	rbtree/rbtree.c	/^void fixup_insert(rbtree *tree, rbnode *node)$/;"	f
high	include/itree.h	/^	int high;$/;"	m	struct:inode
inode	include/itree.h	/^typedef struct inode {$/;"	s
inode	include/itree.h	/^} inode;$/;"	t	typeref:struct:inode
insert_into_leaf	bptree/bptree.c	/^bool insert_into_leaf(bptree *tree, bptree_node_key *leaf_key, void *key, void *data)$/;"	f
insert_key	bptree/bptree.c	/^void insert_key(bptree *tree, bptree_node *node, int node_type, void *key, void *child_or_data)$/;"	f
insert_node_after	bptree/bptree.c	/^bptree_node *insert_node_after(bptree *tree, bptree_node *node)$/;"	f
insert_with_node_key	bptree/bptree.c	/^bool insert_with_node_key(bptree *tree, bptree_node_key *leaf_key, void *key, void *data)$/;"	f
itree	include/itree.h	/^typedef struct itree {$/;"	s
itree	include/itree.h	/^} itree;$/;"	t	typeref:struct:itree
itree_del	itree/itree.c	/^void itree_del(itree *tree, inode *node)$/;"	f
itree_destroy	itree/itree.c	/^void itree_destroy(itree *tree)$/;"	f
itree_find	itree/itree.c	/^inode * itree_find(itree *tree, int low, int high)$/;"	f
itree_init	itree/itree.c	/^itree * itree_init()$/;"	f
itree_insert	itree/itree.c	/^int itree_insert(itree *tree, inode *node)$/;"	f
itree_node_ext_fixup	itree/itree.c	/^void itree_node_ext_fixup(rbnode *node)$/;"	f
itree_node_init	itree/itree.c	/^void itree_node_init(inode *node, int low, int high)$/;"	f
itree_print	itree/itree.c	/^void itree_print(itree *tree)$/;"	f
key	include/bptree.h	/^	void *key;$/;"	m	struct:bptree_node_key_
key	include/rbtree.h	/^	int key;$/;"	m	struct:rbnode
key	include/skiplist.h	/^	int key;$/;"	m	struct:sl_node
key_num	include/bptree.h	/^	int key_num;$/;"	m	struct:bptree_node_
keys	include/bptree.h	/^	bptree_node_key *keys;$/;"	m	struct:bptree_node_
left	include/rbtree.h	/^	struct rbnode * left;$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
level	include/skiplist.h	/^	int level;$/;"	m	struct:sl_node
list	dlist/main.c	/^	struct list_head list;$/;"	m	struct:test_node	typeref:struct:test_node::list_head	file:
list	include/skiplist.h	/^	struct list_head list[MAX_LEVEL];$/;"	m	struct:skiplist	typeref:struct:skiplist::list_head
list	include/skiplist.h	/^	struct list_head list[MAX_LEVEL];$/;"	m	struct:sl_node	typeref:struct:sl_node::list_head
list_add	dlist/dlist.c	/^void list_add(struct list_head *entry, struct list_head *head)$/;"	f
list_del	dlist/dlist.c	/^void list_del(struct list_head *entry)$/;"	f
list_empty	dlist/dlist.c	/^bool list_empty(struct list_head *entry)$/;"	f
list_for_each	include/dlist.h	26;"	d
list_head	include/dlist.h	/^struct list_head {$/;"	s
list_init	dlist/dlist.c	/^void list_init(struct list_head *entry)$/;"	f
list_is_head	dlist/dlist.c	/^bool list_is_head(struct list_head *entry, struct list_head *head)$/;"	f
list_is_tail	dlist/dlist.c	/^bool list_is_tail(struct list_head *entry, struct list_head *head)$/;"	f
low	include/itree.h	/^	int low;$/;"	m	struct:inode
m	include/bptree.h	/^	int m;$/;"	m	struct:bptree_
main	bptree/main.c	/^int main(int argc, char **argv)$/;"	f
main	dlist/main.c	/^int main(int argc, char **argv)$/;"	f
main	itree/main.c	/^int main(int argc, char **argv)$/;"	f
main	rbtree/main.c	/^int main(int argc, char **argv)$/;"	f
main	skiplist/main.c	/^int main(int argc, char **argv)$/;"	f
max	include/itree.h	/^	int max;$/;"	m	struct:inode
merge	bptree/bptree.c	/^void merge(bptree *tree, bptree_node *node)$/;"	f
merge_sibling_node	bptree/bptree.c	/^void merge_sibling_node(bptree *tree, bptree_node *left, bptree_node *right)$/;"	f
modify_key	bptree/bptree.c	/^void modify_key(bptree *tree, bptree_node *node, void *key_old, void *key)$/;"	f
next	include/bptree.h	/^	struct bptree_node_ *next;$/;"	m	struct:bptree_node_	typeref:struct:bptree_node_::bptree_node_
next	include/dlist.h	/^	struct list_head *prev, *next;$/;"	m	struct:list_head	typeref:struct:list_head::
node	include/itree.h	/^	rbnode node;$/;"	m	struct:inode
node	rbtree/main.c	/^	rbnode node;$/;"	m	struct:test_node	file:
node	skiplist/main.c	/^	sl_node node;$/;"	m	struct:test_node	file:
node_del	skiplist/skiplist.c	/^void node_del(sl_node *node)$/;"	f
node_ext_fixup	include/rbtree.h	/^	void (*node_ext_fixup)(rbnode *);$/;"	m	struct:rbtree
node_ext_fixup_default	rbtree/rbtree.c	/^void node_ext_fixup_default(rbnode *node)$/;"	f
node_ext_fixup_to_root	rbtree/rbtree.c	/^void node_ext_fixup_to_root(rbtree *tree, rbnode *node)$/;"	f
node_fill_factor	bptree/bptree.c	/^int node_fill_factor(bptree *tree, bptree_node *node)$/;"	f
node_is_full	bptree/bptree.c	/^bool node_is_full(bptree *tree, bptree_node *node)$/;"	f
node_is_root	bptree/bptree.c	/^bool node_is_root(bptree_node *node)$/;"	f
node_type	include/bptree.h	/^	enum NODE_TYPE node_type;$/;"	m	struct:bptree_node_	typeref:enum:bptree_node_::NODE_TYPE
parent	include/bptree.h	/^	struct bptree_node_ *parent;$/;"	m	struct:bptree_node_	typeref:struct:bptree_node_::bptree_node_
parent	include/rbtree.h	/^	struct rbnode * parent;$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
prev	include/bptree.h	/^	struct bptree_node_ *prev;$/;"	m	struct:bptree_node_	typeref:struct:bptree_node_::bptree_node_
prev	include/dlist.h	/^	struct list_head *prev, *next;$/;"	m	struct:list_head	typeref:struct:list_head::list_head
print_node	bptree/bptree.c	/^void print_node(bptree *tree, bptree_node *node)$/;"	f
print_tree	bptree/main.c	/^static void print_tree(bptree *tree)$/;"	f	file:
rbnode	include/rbtree.h	/^typedef struct rbnode {$/;"	s
rbnode	include/rbtree.h	/^} rbnode;$/;"	t	typeref:struct:rbnode
rbtree	include/rbtree.h	/^typedef struct rbtree {$/;"	s
rbtree	include/rbtree.h	/^} rbtree;$/;"	t	typeref:struct:rbtree
rbtree_check	rbtree/rbtree.c	/^void rbtree_check(rbtree *tree)$/;"	f
rbtree_del	rbtree/rbtree.c	/^void rbtree_del(rbtree *tree, rbnode *node)$/;"	f
rbtree_destroy	rbtree/rbtree.c	/^void rbtree_destroy(rbtree *tree)$/;"	f
rbtree_find	rbtree/rbtree.c	/^rbnode * rbtree_find(rbtree *tree, int key)$/;"	f
rbtree_init	rbtree/rbtree.c	/^rbtree * rbtree_init(void (*node_ext_fixup)(rbnode *))$/;"	f
rbtree_insert	rbtree/rbtree.c	/^int rbtree_insert(rbtree *tree, rbnode *node)$/;"	f
rbtree_node_init	rbtree/rbtree.c	/^void rbtree_node_init(rbnode *node, int key)$/;"	f
rbtree_print	rbtree/rbtree.c	/^void rbtree_print(rbtree *tree) {$/;"	f
rbtree_print_node	rbtree/rbtree.c	/^void rbtree_print_node(rbnode *node, int left_or_right) {$/;"	f
right	include/rbtree.h	/^	struct rbnode * right;$/;"	m	struct:rbnode	typeref:struct:rbnode::rbnode
root	include/bptree.h	/^	bptree_node *root;$/;"	m	struct:bptree_
root	include/itree.h	/^	rbtree * root;$/;"	m	struct:itree
root	include/rbtree.h	/^	rbnode * root;$/;"	m	struct:rbtree
rotate_left	rbtree/rbtree.c	/^void rotate_left(rbtree *tree, rbnode *node)$/;"	f
rotate_right	rbtree/rbtree.c	/^void rotate_right(rbtree *tree, rbnode *node)$/;"	f
search_key	bptree/bptree.c	/^int search_key(bptree *tree, bptree_node *node, void *key, int search_type, int rw) $/;"	f
search_leaf_node	bptree/bptree.c	/^bptree_node_key *search_leaf_node(bptree *tree, bptree_node *node, void *key, int rw)$/;"	f
search_node	bptree/bptree.c	34;"	d	file:
skiplist	include/skiplist.h	/^struct skiplist {$/;"	s
skiplist_del	skiplist/skiplist.c	/^void skiplist_del(struct skiplist *sl, int key)$/;"	f
skiplist_destroy	skiplist/skiplist.c	/^void skiplist_destroy(struct skiplist *sl)$/;"	f
skiplist_find	skiplist/skiplist.c	/^sl_node * skiplist_find(struct skiplist *sl, int key)$/;"	f
skiplist_init	skiplist/skiplist.c	/^struct skiplist * skiplist_init()$/;"	f
skiplist_insert	skiplist/skiplist.c	/^void skiplist_insert(struct skiplist *sl, sl_node *node)$/;"	f
skiplist_node_init	skiplist/skiplist.c	/^void skiplist_node_init(sl_node *node, int key)$/;"	f
skiplist_print	skiplist/skiplist.c	/^void skiplist_print(struct skiplist *sl)$/;"	f
sl_node	include/skiplist.h	/^typedef struct sl_node {$/;"	s
sl_node	include/skiplist.h	/^} sl_node;$/;"	t	typeref:struct:sl_node
split	bptree/bptree.c	/^void split(bptree *tree, bptree_node *node)$/;"	f
successor	rbtree/rbtree.c	/^rbnode * successor(rbtree *tree, rbnode *node)$/;"	f
test	skiplist/main.c	/^void test() {$/;"	f
test_node	dlist/main.c	/^typedef struct test_node {$/;"	s	file:
test_node	dlist/main.c	/^} test_node;$/;"	t	typeref:struct:test_node	file:
test_node	itree/main.c	/^typedef struct test_node {$/;"	s	file:
test_node	itree/main.c	/^} test_node;$/;"	t	typeref:struct:test_node	file:
test_node	rbtree/main.c	/^typedef struct test_node {$/;"	s	file:
test_node	rbtree/main.c	/^} test_node;$/;"	t	typeref:struct:test_node	file:
test_node	skiplist/main.c	/^typedef struct test_node {$/;"	s	file:
test_node	skiplist/main.c	/^}test_node;$/;"	t	typeref:struct:test_node	file:
travel	bptree/bptree.c	/^void travel(bptree *tree, bptree_node *node, int depth, void (*do_something)(bptree *tree, bptree_node *))$/;"	f
value	itree/main.c	/^	int value;$/;"	m	struct:test_node	file:
value	rbtree/main.c	/^	int value;$/;"	m	struct:test_node	file:
value	skiplist/main.c	/^	int64_t value;$/;"	m	struct:test_node	file:
